<!doctype html>
<html>
<body>
<script type=module>
import * as THREE from './three.module.js';
window.THREE = THREE;
</script>
<script type=module>
import {GLTFLoader} from './GLTFLoader.js';
import {BufferGeometryUtils} from './BufferGeometryUtils.js';
// import {OrbitControls} from './OrbitControls.js';
import easing from './easing.js';

const cubicBezier = easing(0, 1, 0, 1);

(async () => {

const localVector = new THREE.Vector3();
const localVector2 = new THREE.Vector3();
const localQuaternion = new THREE.Quaternion();
const localEuler = new THREE.Euler();
localEuler.order = 'YXZ';
const localMatrix = new THREE.Matrix4();
const localMatrix2 = new THREE.Matrix4();
const localMatrixWorld = new THREE.Matrix4();
const localVector2D = new THREE.Vector2();

// const userId = Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);

const renderer = new THREE.WebGLRenderer({
  antialias: true,
  alpha: true,
});
// renderer.gammaOutput = true;
// renderer.gammaFactor = 2.2;
renderer.physicallyCorrectLights = true;
// renderer.toneMappingExposure = 1;
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.sortObjects = false;
// renderer.shadowMap.enabled = true;
// renderer.shadowMap.type = THREE.PCFShadowMap;
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.matrixAutoUpdate = false;

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
scene.add(camera);

const ambientLight = new THREE.AmbientLight(0xFFFFFF, 2);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 3);
scene.add(directionalLight);

const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 3);
scene.add(directionalLight2);

/* const cubeGeometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);
const _makeCubeMesh = () => {
  const geometry = cubeGeometry;
  const material = new THREE.MeshPhongMaterial({
    color: 0x333333,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
};
const cubeMesh = _makeCubeMesh();
scene.add(cubeMesh); */

const lightsaberMesh = await (async () => {
  const object = new THREE.Object3D();

  const o = await new Promise((accept, reject) => {
    new GLTFLoader().load('lightsaber.glb', function(o) {
      o = o.scene;
      // console.log('loaded lightsaber', o);
      accept(o);
    }, undefined, reject);
  });
  object.add(o);

  const bladeMaterial = new THREE.MeshPhongMaterial({
    // color: 0x800000,
    color: 0xFF4040,
  });
  const topBladeMesh = (() => {
    const geometry = new THREE.BoxBufferGeometry(0.0125, 0.0125, 1).applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -1/2 - 0.15 + 0.145));
    const mesh = new THREE.Mesh(geometry, bladeMaterial);
    mesh.position.z = -0.145;
    mesh.visible = false;
    mesh.frustumCulled = false;
    return mesh;
  })();
  object.add(topBladeMesh);
  const sideBladeMesh = (() => {
    const geometry = BufferGeometryUtils.mergeBufferGeometries([
      new THREE.BoxBufferGeometry(0.1, 0.0125, 0.0125).applyMatrix(new THREE.Matrix4().makeTranslation(-0.1/2 - 0.06, 0, 0)),
      new THREE.BoxBufferGeometry(0.1, 0.0125, 0.0125).applyMatrix(new THREE.Matrix4().makeTranslation(0.1/2 + 0.06, 0, 0)),
    ]);
    const mesh = new THREE.Mesh(geometry, bladeMaterial);
    mesh.position.z = -0.145;
    mesh.visible = false;
    mesh.frustumCulled = false;
    return mesh;
  })();
  object.add(sideBladeMesh);

  let animation = null;
  object.tick = () => {
    if (animation) {
      const {startFactor, endFactor, startTime, endTime} = animation;
      const now = Date.now();
      const lerp = Math.min(Math.max((now - startTime) / (endTime - startTime), 0), 1);
      let factor = startFactor + (endFactor - startFactor)*lerp;
      if (endFactor > startFactor) {
        factor = cubicBezier(factor);
      }
      topBladeMesh.scale.set(1, 1, factor);
      sideBladeMesh.scale.set(factor, 1, 1);
      topBladeMesh.visible = sideBladeMesh.visible = factor > 0;
      if (lerp >= 1) {
        animation = null;
      }
      return true;
    } else {
      return false;
    }
  };
  let phase = 0;
  object.setState = () => {
    if (phase === 0) {
      const startTime = Date.now();
      const endTime = startTime + 1000;
      animation = {
        startFactor: 0,
        endFactor: 1,
        startTime,
        endTime,
      };
      phase = 1;
    } else if (phase === 1) {
      const startTime = Date.now();
      const endTime = startTime + 2000;
      animation = {
        startFactor: 1,
        endFactor: 1,
        startTime,
        endTime,
      };
      phase = 2;
    } else if (phase === 2) {
      const startTime = Date.now();
      const endTime = startTime + 1000;
      animation = {
        startFactor: 1,
        endFactor: 0,
        startTime,
        endTime,
      };
      phase = 0;
    } else {
      throw new Error('unknown phase');
    }
  };

  /* object.grabIndex = -1;
  window.document.dataset.addEventListener('change', e => {
    const {key, value} = e.detail;
    if (key === 'enabled') {
      bladeMesh.visible = value;
    }
  });
  object.setState = enabled => {
    window.document.dataset.set('enabled', enabled);
  };
  object.getEquipper = () => window.document.dataset.get('equipper');
  object.setEquipper = equipper => {
    window.document.dataset.set('equipper', equipper);
  }; */

  return object;
})();
lightsaberMesh.rotation.order = 'YXZ';
scene.add(lightsaberMesh);

/* const cubeGeometry = new THREE.BoxBufferGeometry(0.02, 0.01, 0.05);
const _makeCubeMesh = () => {
  const geometry = cubeGeometry;
  const material = new THREE.MeshPhongMaterial({
    color: 0x333333,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
};
const cubeMeshes = [
  _makeCubeMesh(),
  _makeCubeMesh(),
];
scene.add(cubeMeshes[0]);
scene.add(cubeMeshes[1]); 

const cameraCubeMesh = (() => {
  const geometry = new THREE.BoxBufferGeometry(0.5, 0.5, 0.5);
  const material = new THREE.MeshPhongMaterial({
    color: 0x333333,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
})()
// scene.add(cameraCubeMesh); */

/* const session = await navigator.xr.requestSession();
session.layers && session.layers.push(renderer.domElement);
session.requestAnimationFrame((timestamp, frame) => {
  renderer.vr.setSession(session, {
    frameOfReferenceType: 'stage',
  });

  const pose = frame.getViewerPose();
  const viewport = session.baseLayer.getViewport(pose.views[0]);
  const height = viewport.height;
  const fullWidth = (() => {
    let result = 0;
    for (let i = 0; i < pose.views.length; i++) {
      result += session.baseLayer.getViewport(pose.views[i]).width;
    }
    return result;
  })();
  renderer.setSize(fullWidth, height);
  renderer.setPixelRatio(1);

  renderer.setAnimationLoop(null);

  renderer.vr.enabled = true;
  renderer.vr.setSession(session);
  renderer.vr.setAnimationLoop(animate);
}); */

/* const lastPresseds = Array(cubeMeshes.length).fill(false);
const lastGrabbeds = Array(cubeMeshes.length).fill(false);
const _setMatrixWorld = matrixWorld => {
  localMatrixWorld
    .compose(
      localVector.fromArray(window.document.xrOffset.position),
      localQuaternion.fromArray(window.document.xrOffset.orientation),
      localVector2.set(1, 1, 1)
    )
    .multiply(matrixWorld)
    .decompose(localVector, localQuaternion, localVector2)
  window.document.xrOffset.position = localVector.toArray();
  window.document.xrOffset.orientation = localQuaternion.toArray();
}; */
let lastUpdateTime = Date.now();
function animate() {
  const now = Date.now();
  const timeDiff = now - lastUpdateTime;

  lightsaberMesh.rotation.x = Math.PI/2 + Math.sin((now%2000)/2000 * Math.PI*2)*0.1;
  lightsaberMesh.rotation.y = Math.sin((now%3000)/3000 * Math.PI*2);
  if (!lightsaberMesh.tick()) {
    lightsaberMesh.setState();
  }

  /* if (lightsaberMesh.getEquipper() === userId) {
    localMatrix
      .copy(vrCamera.matrixWorld)
      .premultiply(
        localMatrix2.fromArray(window.document.xrOffset.matrix)//.getInverse(localMatrix2)
      )
      .decompose(localVector, localQuaternion, localVector2);

    localEuler.setFromQuaternion(localQuaternion, localEuler.order);
    localEuler.x = 0;
    localEuler.z = 0;
    localQuaternion.setFromEuler(localEuler);

    localVector
      .add(localVector2.set(0, -0.5, 0))
      .add(
        localVector2
          .set(0.2, 0, 0)
          .applyQuaternion(localQuaternion)
      );

    window.document.xrOffset.position = localVector.toArray();
    window.document.xrOffset.orientation = localQuaternion.toArray();
  } */

  renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);

let currentSession = null;
function onSessionStarted(session) {
  session.addEventListener('end', onSessionEnded);

  renderer.xr.setSession(session);

  currentSession = session;
}
function onSessionEnded() {
  currentSession.removeEventListener('end', onSessionEnded);

  currentSession = null;
}
navigator.xr && navigator.xr.requestSession('immersive-vr', {
  optionalFeatures: [
    'local-floor',
    'bounded-floor',
  ],
}).then(onSessionStarted);

})();
</script>
</body>
</html>
